diff --git a/src/cogent3/core/new_alignment.py b/src/cogent3/core/new_alignment.py
index ffcba70a6..bd1ae9585 100644
--- a/src/cogent3/core/new_alignment.py
+++ b/src/cogent3/core/new_alignment.py
@@ -234,6 +234,51 @@ def _(seq: numpy.ndarray, moltype: MolType) -> tuple[str, IndelMap]:
     return ungapped, indel_map
 
 
+def gap_coords_to_seq(ungapped_seq: str, gap_positions: GapPositions) -> str:
+    """
+    Takes the outputs from seq_to_gap_coords() to reconstruct the original
+    sequence with gaps interleaved.
+
+    Parameters
+    ----------
+    ungapped_seq
+        Sequence with gaps parsed out from seq_to_gap_coords()
+
+    gap_positions
+        GapPositions() class from seq_to_gap_coords()
+
+    Returns
+    -------
+    gapped
+        Sequence with gaps inserted.
+    """
+    if ungapped_seq is None:
+        # All gaps
+        return "-" * gap_positions.seq_length
+
+    if gap_positions.gaps.size == 0:
+        # No gaps
+        return ungapped_seq
+
+    gapped = ""
+    offset = 0
+    frag_start = 0
+    for gap_start, gap_length in gap_positions.gaps:
+        # Adjust from aligned indicies to ungapped
+        # i.e. offsets by the total gaps added
+        frag_start -= offset
+        frag_end = gap_start - offset
+        # Slice ungapped
+        gapped += ungapped_seq[frag_start:frag_end]
+        gapped += "-" * gap_length
+        # Update counters for next iteration
+        offset += gap_length
+        frag_start = len(gapped)
+    # If ends with frag
+    gapped += ungapped_seq[frag_end:]
+    return gapped
+
+
 class AlignedDataView(SeqDataView):
     """
     Example
@@ -243,10 +288,34 @@ class AlignedDataView(SeqDataView):
     adv = sd.get_aligned_view(seqid="seq1")
     """
 
+    # methods for outputting different data types will need to be overridden
+    @property
+    def value(self) -> str:
+        coords, ungapped = self.seq.get_gaps(seqid=self.seqid)
+        aligned = gap_coords_to_seq(coords, ungapped)
+        str_aligned = str(aligned)
+        raw_seq = str_aligned[self.parent_start : self.parent_stop]
+        # raw_seq = self.seq.get_seq_str(
+        #    seqid=self.seqid, start=self.parent_start, stop=self.parent_stop
+        # )
+
+        return raw_seq if self.step == 1 else raw_seq[:: self.step]
+
+    # def value()
+    # if not sliced return original string
+    # _convert.gap_coords_to_seq and vice versa
+    # raw_seqs and raw_gaps from AlignedData
+    # Method on AlignedData - get seq and get gaps
+    # pass seqid only, for now
+
+    # TODO: 3. def array_value() -> index and gaps
+    # TODO: 4. def bytes_value() -> index and gaps
+
 
 @dataclass
 class AlignedData:
     # Look out for any overlaps with SeqData
+    # Check: Made seqs and gaps optional for classmethod to work?
     seqs: Optional[dict[str, numpy.ndarray]] = None
     gaps: Optional[dict[str, numpy.ndarray]] = None
     _moltype: MolType = field(init=False)
@@ -282,7 +351,7 @@ class AlignedData:
         seqs = {}
         gaps = {}
         for name, seq in data.items():
-            seqs[name], gaps[name] = seq_to_gap_coords(seq, moltype)
+            seqs[name], gaps[name] = seq_to_gap_coords(seq)
 
         name_order = process_name_order(seqs, name_order)
 
@@ -298,5 +367,39 @@ class AlignedData:
         # Need to revisit what the variable is called i.e. parent_length
         return AlignedDataView(self, seqid=seqid, seq_len=self.align_len)
 
+    def get_seq_array(
+        self, *, seqid: str, start: int = None, stop: int = None
+    ) -> numpy.ndarray:
+        # TODO: Figure out how to slice by converting seq_coords to
+        # align_coords. GapPositions() has a method that does this
+        seq = self.seqs[seqid]
+        gap_coord = self.get_gaps(seqid)
+        # Length of result to return (align_len)
+        # Create empty array of align_len
+        # Place gaps correctly
+        # Place seqs correctly
+        # result[:] = gap_char
+        # write a function that takes the gappos,
+        # and returns the sequence coordinates for the ungapped segments
+        # and also returns the corresponding alignment coordinates too
+        #   01 234  seq coord
+        # --AG-GGT--
+        # 0123456789  al coord
+        # [(0, 2), (2, 1), (5, 2)] thats gap_pos.gaps
+        # (0, 2) and (2, 5) are the ungapped segments
+        # their corresponding alignment coordinates
+        # (2, 4) and (5, 8)
+        return gap_coords_to_seq(self.seqs[seqid], self.gaps[seqid])[start:stop]
+
+    def get_seq_str(self, *, seqid: str, start: int = None, stop: int = None) -> str:
+        return self._alpha.from_indices(
+            self.get_seq_array(seqid=seqid, start=start, stop=stop)
+        )
+
+    def get_seq_bytes(
+        self, *, seqid: str, start: int = None, stop: int = None
+    ) -> bytes:
+        return self.get_seq_str(seqid=seqid, start=start, stop=stop).encode("utf8")
+
     def get_gaps(self, seqid: str) -> numpy.ndarray:
         return self.gaps[seqid]
diff --git a/tests/test_core/test_new_alignment.py b/tests/test_core/test_new_alignment.py
index 7bad7bc77..c2e05fe4c 100644
--- a/tests/test_core/test_new_alignment.py
+++ b/tests/test_core/test_new_alignment.py
@@ -9,6 +9,7 @@ from cogent3.core.new_alignment import (
     AlignedDataView,
     SeqData,
     SeqDataView,
+    gap_coords_to_seq,
     process_name_order,
     seq_index,
     seq_to_gap_coords,
@@ -314,6 +315,41 @@ def test_aligned_from_string_returns_self(aligned_dict):
     # assert gap lengths
 
 
+# AlignedData get_seq_* tests
+def test_aligned_get_seq_array(aligned_dict):
+    expect = numpy.array([2, 1, 3, 0], dtype="uint8")
+    ad = AlignedData.from_gapped_seqs(data=aligned_dict)
+    got = ad.get_seq_array(seqid="seq1")
+    assert numpy.array_equal(got, expect)
+
+
+@pytest.mark.parametrize("seq", ("seq1", "seq2"))
+@pytest.mark.parametrize("start", (None, -1, 0, 1, 4))
+@pytest.mark.parametrize("stop", (None, -1, 0, 1, 4))
+def test_aligned_get_seq_str(aligned_dict, seq, start, stop):
+    # slicing should be tested in test_aligned_get_seq_array
+    expect = aligned_dict[seq][start:stop]
+    sd = SeqData(data=aligned_dict)
+    got = sd.get_seq_str(seqid=seq, start=start, stop=stop)
+    assert expect == got
+
+
+def test_aligned_get_seq_bytes(aligned_dict):
+    ad = AlignedData.from_gapped_seqs(aligned_dict)
+    got = ad.get_seq_bytes(seqid="seq1")
+    assert isinstance(got, bytes)
+
+
+@pytest.mark.parametrize(
+    "seqid, expect", [("seq1", numpy.array([[3, 2]])), ("seq2", numpy.array([[0, 1]]))]
+)
+def test_get_gaps(aligned_dict, seqid, expect):
+    ad = AlignedData.from_gapped_seqs(aligned_dict)
+    gap_pos = ad.get_gaps(seqid)
+    got = gap_pos.gaps
+    assert numpy.array_equal(got, expect)
+
+
 @pytest.mark.parametrize("seqid", ("seq1", "seq2"))
 def test_get_aligned_view(aligned_dict, seqid):
     ad = AlignedData.from_gapped_seqs(aligned_dict)
@@ -324,6 +360,20 @@ def test_get_aligned_view(aligned_dict, seqid):
     assert got.seq_len == ad.align_len
 
 
+# @pytest.mark.parametrize("start", (None, 0, 1, 4, -1, -4))
+# @pytest.mark.parametrize("stop", (None, 0, 1, 4, -1, -4))
+# @pytest.mark.parametrize("step", (None, 1, 2, 3, -1, -2, -3))
+# def test_aligneddataview_value(aligned_dict: dict, start, stop, step):
+#    seq = "seq2"
+#    expect = aligned_dict[seq][start:stop:step]
+#    ad = AlignedData.from_gapped_seqs(aligned_dict)
+#    # Get AlignedDataView on seq
+#    adv = ad.get_aligned_view(seqid=seq)
+#    adv2 = adv[start:stop:step]
+#    got = adv2.value
+#    assert got == expect
+
+
 # AlignedData seq to gaps
 def test_seq_to_gap_coords_str_all_gaps():
     parent_seq = "-----"
@@ -381,3 +431,24 @@ def test_seq_to_gap_coords_arr(gap_seqs, i):
     got_ungapped, got_map = seq_to_gap_coords(seq, moltype=get_moltype("dna"))
     assert numpy.array_equal(got_ungapped, seq[seq != 4])  # gap_char = 4
     assert got_map.get_gap_coordinates() == gap_coords
+
+
+@pytest.mark.parametrize("test_index", range(3))
+def test_gap_coords_to_seq(gapped_ungapped_gappos, test_index):
+    expect_gapped, expect_ungapped, expect_GP = gapped_ungapped_gappos[test_index]
+    got_gapped = gap_coords_to_seq(expect_ungapped, expect_GP)
+    assert got_gapped == expect_gapped
+
+
+def test_gap_coords_to_seq_allgaps():
+    seq = "----"
+    ug, gp = seq_to_gap_coords(seq)
+    got = gap_coords_to_seq(ug, gp)
+    assert got == seq
+
+
+def test_gap_coords_to_seq_nogaps():
+    seq = "ACTG"
+    ug, gp = seq_to_gap_coords(seq)
+    got = gap_coords_to_seq(ug, gp)
+    assert got == seq
